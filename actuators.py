# This file defines the ActuatorBoard class, which handles
# communications with the actuator-controlling boards. You can tell a
# Board to send any of several commands to any port.
#
# It might seem odd to not have an Actuator class. Let me give my
# rationale for that decision:
#  - When I wrote the Actuator class, it ended up just being a wrapper
#    around the Board class, passing its port number into Board method
#    calls.
#  - There is no way to obtain a list of all the actuators, or to tell
#    whether an actuator on a given port exists. We communicate with
#    an actuator by telling the board to send a command to some port,
#    and what we hear back is independent of whether that actuator
#    exists.
#  - "But you could store actuator-specific information like position
#    in an Actuator instance." Actually, no, not very well. Things
#    like position vary silently, meaning the only way to know what they
#    are at any moment is to ask the board. We could give the Actuator
#    a getPosition() method that would query the board about its
#    position, but that would just be a thin wrapper around the board's
#    get_status method, and, in my mind, it's not worth the confusion
#    generated by the other problems with an Actuator class.
#

# We use the JavaFTD2XX library to talk with the actuator boards.
from . import java

# We need to pack long-type values into bytestrings which we send to
# the board. The struct package can do that.
import struct

# When we're controlling the actuators, there are two FTDI devices
# hooked up to the computer. These are currently the serial numbers of
# those devices.
FT232_SERIAL_NUMBER = "A6007pN3"
FT245_SERIAL_NUMBER = "A3000wLU"

# The actuator boards expect to be told a number of "steps" to move
# their actuators, but we'd like client code to be in terms of actual
# distances. This is the conversion rate between the two.
ACTUATOR_MICRONS_PER_STEP = 1. # CURRENTLY A DUMMY VALUE
ACTUATOR_STEPS_PER_MICRON = 1 / ACTUATOR_MICRONS_PER_STEP

# Convenience function to avoid crazy long lines when we access
# JavaFTD2XX stuff:
def get_ftdi():
    """Returns the com.ftdi package of the JVM we're using."""
    return java.get_gateway().jvm.com.ftdi

class HandleWrapper(object):
    """A wrapper around a D2XX handle. Just boilerplate open/close stuff."""
    def __init__(self, serial_number):
        self.serial_number = serial_number
        self.handle = None

    def open(self):
        """Opens and configures the internal handle."""
        FTDevice = get_ftdi().FTDevice
        devices = FTDevice.getDevicesBySerialNumber(self.serial_number)
        if len(devices) == 0:
            raise RuntimeError("no devices with serial number {} are available"
                               .format(self.serial_number))
        self.handle = devices[0]
        self.configure_handle()

    def close(self):
        """Closes the internal handle."""
        self.handle.close()
        self.handle = None
    def __del__(self):
        if self.handle is not None:
            self.handle.close()

    def configure_handle(self):
        """Does any necessary prep work on the internal handle."""
        pass

    def read(self, number_of_bytes):
        return str(self.handle.read(number_of_bytes))
    def write(self, message):
        return self.handle.write(bytearray(message))

class FT232Wrapper(HandleWrapper):
    """Wraps the half of the board that we read/write most messages from."""
    def configure_handle(self):
        self.handle.setBaudRate(9600)
        self.handle.setDataCharacteristics(get_ftdi().WordLength.BITS_8,
                                           get_ftdi().StopBits.STOP_BITS_1,
                                           get_ftdi().Parity.PARITY_NONE)

    def clear_messages(self):
        self.handle.purgeBuffer(True, False)
        #self.handle.setTimeouts(10, 65000)
        #while self.read(1000):
        #    pass
        #self.handle.setTimeouts(65000, 65000)
    def read(self):
        result = ''
        while not result.endswith('eol'):
            result += HandleWrapper.read(self, 1)
        return result[:-3].strip()
    def write(self, message):
        checksum = reduce(lambda chk, c: chk^ord(c),
                          message, 0)
        return HandleWrapper.write(self, message + chr(checksum))


class FT245Wrapper(HandleWrapper):
    """Wraps the half of the board that sets the port."""
    def configure_handle(self):
        self.handle.setBitMode(0xFF, get_ftdi().BitModes.BITMODE_ASYNC_BITBANG)

    def set_port(self, port):
        bits = bin(port)[2:]
        flipped = int(''.join(reversed(bits)), 2)
        HandleWrapper.write(self, flipped)


class ActuatorBoard(object):
    """Allows client code two-way communications with the actuator setup."""
    def __init__(self, ft232_serial_number=FT232_SERIAL_NUMBER,
                 ft245_serial_number=FT245_SERIAL_NUMBER):
        self.ft232_wrapper = FT232Wrapper(ft232_serial_number)
        self.ft245_wrapper = FT245Wrapper(ft245_serial_number)

    def __enter__(self):
        self.open()
        return self
    def __exit__(self, exc_type, exc_value, traceback):
        self.close()
    
    def open(self):
        self.ft232_wrapper.open()
        self.ft245_wrapper.open()
    def close(self):
        self.ft232_wrapper.close()
        self.ft245_wrapper.close()
    
    def read(self):
        return self.ft232_wrapper.read()
    def write(self, message, port):
        self.ft245_wrapper.set_port(port)
        return self.ft232_wrapper.write(message)
    
    def filtered_read(self, filter):
        result = self.read()
        while not filter(result):
            result = self.read()
        return result
    def read_status_message(self):
        return self.filtered_read(Status.is_status_message)
    def read_nonstatus_message(self):
        return self.filtered_read(lambda s: not Status.is_status_message(s))
        
    def move(self, microns, port):
        steps = round(microns * ACTUATOR_STEPS_PER_MICRON)
        self.write('\x50' + struct.pack('>l', steps), port)
    def move_absolute(self, microns, port):
        steps = round(microns * ACTUATOR_STEPS_PER_MICRON)
        self.write('\xB0' + struct.pack('>l', steps), port)
    def motor_on(self, port):
        self.write('\x11\xff', port)
    def motor_off(self, port):
        self.write('\x11\x00', port)
    def motor_off_hard(self, port):
        self.write('\x15\x00', port)
    def request_status(self, port):
        self.write('\x3C', port)
    
    def get_status(self, port):
        self.ft232_wrapper.clear_buffer()
        self.request_status(port)
        return Status(string=self.read_status_message())


class Status(object):
    """Contains the information conveyed by a status message."""
    def __init__(self, position=None, potentiometer_value=None,
                 encoder_value=None, home=None, string=None):
        # When we ask for a status, we receive back some string
        # describing it. It looks like
        #   blah blah blah POSITION blah POTENTIOMETER blah ENCODER HOME?
        # and we can parse it if we have to:
        if string is not None:
            split = string.split(" ")
            blah, blah, blah, posn, blah, pot, blah, enc, home_str = (
                string.split(" "))
            position = int(posn)
            potentiometer_value = int(pot)
            encoder_value = int(enc)
            home = (home_str == "MtrHome")
        if ((position is None) or (potentiometer_value is None) or
            (encoder_value is None) or (home is None)):
            raise ValueError("Status takes four arguments or string keyword")
        self.position = position
        self.potentiometer_value = potentiometer_value
        self.encoder_value = encoder_value
        self.home = home

    def __str__(self):
        return "(posn={}, pot={}, enc={}, home={})".format(
            self.position, self.potentiometer_value,
            self.encoder_value, self.home)
    
    @staticmethod
    def is_status_message(string):
        """Returns whether a string can be parsed into a status message."""
        try:
            Status(string=string)
        except ValueError:
            return False
        else:
            return True


class DummyBoard(object):
    def __init__(self, ft232_serial_number=FT232_SERIAL_NUMBER,
                 ft245_serial_number=FT245_SERIAL_NUMBER):
        pass
    def __enter__(self):
        return self
    def __exit__(self, exc_type, exc_value, traceback):
        pass
    def open(self):
        pass
    def close(self):
        pass
    def move(self, microns, port):
        pass
    def move_absolute(self, microns, port):
        pass
    def motor_on(self, port):
        pass
    def motor_off(self, port):
        pass
    def motor_off_hard(self, port):
        pass
    def request_status(self, port):
        pass
    def read(self):
        return ''
    def write(self, message, port):
        return 0
    def get_status(self, port):
        return Status(0, 0, 0, False)

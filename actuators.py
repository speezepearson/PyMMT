# This file defines the ActuatorBoard class, which handles
# communications with the actuator-controlling boards. You can tell a
# Board to send one of several commands to any port (each command
# corresponding to a method of the Board class, e.g. "move",
# "request_status").
#
# It might seem odd to not have an Actuator class. Let me give my
# rationale for that decision:
#  - When I wrote the Actuator class, it ended up just being a wrapper
#    around the Board class, passing its port number into Board method
#    calls.
#  - There is no way to obtain a list of all the actuators, or to tell
#    whether an actuator on a given port exists. We communicate with
#    an actuator by telling the board to send a command to some port,
#    and what we hear back is independent of whether that actuator
#    exists.
#  - "But you could store actuator-specific information like position
#    in an Actuator instance." Actually, no, not very well. Things
#    like position vary silently, meaning the only way to know what they
#    are at any moment is to ask the board. We could give the Actuator
#    a getPosition() method that would query the board about its
#    position, but that would just be a thin wrapper around the board's
#    get_status method, and, in my mind, it's not worth the confusion
#    generated by the other problems with an Actuator class.
#

import logging
from . import dummyd2xx as _dummyd2xx
try:
    import d2xx as _d2xx
except ImportError:
    # We don't have the d2xx library.
    logging.warning("Failed to load the real d2xx library.")
    _d2xx = _dummyd2xx
d2xx = _d2xx
    
# We need threading to make ActuatorBoards thread-safe (by giving them
# locks which are acquired by their read and write methods); struct to
# pack long values into bytestrings which we send to the board; and
# packetqueue to manage access to the messages coming in from the board.
import threading
import struct
from srptools import packetqueue

# These are the serial numbers of the FTDI thingies we're currently using
# to control the actuators. We need them to open the devices.
FT232_SERIAL_NUMBER = "A6007pN3"
FT245_SERIAL_NUMBER = "A3000wLU"

# Features of the actuators we're using -- we'd like client code to be
# in terms of actual distances, but the boards talk in terms of numbers
# of "steps." We internally throw in a conversion between them.
ACTUATOR_MICRONS_PER_STEP = 1. # CURRENTLY A DUMMY VALUE
ACTUATOR_STEPS_PER_MICRON = 1 / ACTUATOR_MICRONS_PER_STEP

def set_dummy(dummy):
    """Configures actuator boards to use/not use the dummy D2XX library."""
    if dummy:
        logging.warning("Configuring PyMMT.actuators to use the dummy d2xx")
        d2xx = _dummyd2xx
    elif _d2xx is _dummyd2xx:
        logging.warning("Don't have the real d2xx library: must use dummy")
        d2xx = _dummyd2xx
    else:
        logging.info("Configuring PyMMT.actuators to use the real d2xx")
        d2xx = _d2xx

class HandleWrapper(object):
    """A wrapper around a D2XX handle. Just boilerplate open/close stuff."""
    def __init__(self, serial_number):
        self.serial_number = serial_number
        self.handle = None

    def open(self):
        """Opens and configures the internal handle."""
        self.handle = d2xx.openEx(self.serial_number,
                                  d2xx.OPEN_BY_SERIAL_NUMBER)
        self.configure_handle()
    def configure_handle(self):
        """Does any necessary prep work on the internal handle."""
        pass
    def close(self):
        """Closes the internal handle."""
        self.handle.close()
        self.handle = None
    def __del__(self):
        if self.handle is not None:
            self.handle.close()

def extract_packet(string):
    """Returns the first packet and remainder of the given string."""
    if 'eol' in string:
        packet, remainder = string.split('eol', 1)
        return (packet.strip(), remainder)
    return (None, None)
class FT232Wrapper(HandleWrapper):
    """Wraps the half of the board that we read messages from."""
    def configure_handle(self):
        self.handle.setBaudRate(d2xx.BAUD_9600)
        self.handle.setDataCharacteristics(d2xx.BITS_8,
                                           d2xx.STOP_BITS_1,
                                           d2xx.PARITY_NONE)
        self.packet_queue = packetqueue.PacketQueue(self._read_one_byte,
                                                    extract_packet)

    def _read_one_byte(self):
        return self.handle.read(1)

    def open(self):
        HandleWrapper.open(self)
        self.packet_queue.start_adding()

    def read(self):
        return self.packet_queue.pop()

class FT245Wrapper(HandleWrapper):
    """Wraps the half of the board that we write messages to."""
    def configure_handle(self):
        self.handle.setBitMode(0xFF, d2xx.BITMODE_ASYNC_BITBANG)

    def set_port(self, port):
        bits = bin(port)[2:]
        flipped = int(''.join(reversed(bits)), 2)
        self.handle.write(chr(flipped))

    def write(self, message, port):
        self.set_port(port)

        checksum = 0
        for byte in message:
            checksum ^= ord(byte)
        return self.handle.write(message + chr(checksum))

class ActuatorBoard(object):
    """Allows client code two-way communications with the actuator setup."""
    def __init__(self, ft232_serial_number=FT232_SERIAL_NUMBER,
                 ft245_serial_number=FT245_SERIAL_NUMBER):
        self.ft232_wrapper = FT232Wrapper(ft232_serial_number)
        self.ft245_wrapper = FT245Wrapper(ft245_serial_number)
        self.lock = threading.RLock()
    def __enter__(self):
        print "Opening board..."
        self.open()
        print "Opened!"
        return self
    def __exit__(self, type, value, traceback):
        print "Closing board..."
        self.close()
        print "Closed."
    
    def open(self):
        self.ft232_wrapper.open()
        self.ft245_wrapper.open()
    def close(self):
        self.ft232_wrapper.close()
        self.ft245_wrapper.close()
    
    def read(self):
        with self.lock:
            return self.ft232_wrapper.read()
    def write(self, message, port):
        with self.lock:
            return self.ft245_wrapper.write(message, port)
    def clear_packets(self):
        self.ft232_wrapper.packet_queue.clear()
    
    def filtered_read(self, filter):
        result = self.read()
        while not filter(result):
            result = self.read()
        return result
    def read_status_message(self):
        return self.filtered_read(Status.is_status_message)
    def read_nonstatus_message(self):
        return self.filtered_read(lambda s: not Status.is_status_message(s))
        
    def move(self, microns, port):
        steps = round(microns * ACTUATOR_STEPS_PER_MICRON)
        self.write('\x50' + struct.pack('>l', steps), port)
    def move_absolute(self, microns, port):
        steps = round(microns * ACTUATOR_STEPS_PER_MICRON)
        self.write('\xB0' + struct.pack('>l', steps), port)
    def motor_on(self, port):
        self.write('\x11\xff', port)
    def motor_off(self, port):
        self.write('\x11\x00', port)
    def motor_off_hard(self, port):
        self.write('\x15\x00', port)
    def request_status(self, port):
        self.write('\x3C', port)
    
    def get_status(self, port):
        with self.lock:
            self.ft232_wrapper.packet_queue.clear()
            self.request_status(port)
            return Status(string=self.read_status_message())


class Status(object):
    """Contains the information conveyed by a status message."""
    def __init__(self, position=None, potentiometer_value=None,
                 encoder_value=None, home=None, string=None):
        # When we ask for a status, we receive back some string
        # describing it. It looks like
        #   blah blah blah POSITION blah POTENTIOMETER blah ENCODER HOME?
        # and we can parse it if we have to:
        if string is not None:
            split = string.split(" ")
            blah, blah, blah, posn, blah, pot, blah, enc, home_str = (
                string.split(" "))
            position = int(posn)
            potentiometer_value = int(pot)
            encoder_value = int(enc)
            home = (home_str == "MtrHome")
        if ((position is None) or (potentiometer_value is None) or
            (encoder_value is None) or (home is None)):
            raise ValueError("Status takes four arguments or string keyword")
        self.position = position
        self.potentiometer_value = potentiometer_value
        self.encoder_value = encoder_value
        self.home = home

    def __str__(self):
        return "(posn={}, pot={}, enc={}, home={})".format(
            self.position, self.potentiometer_value,
            self.encoder_value, self.home)
    
    @staticmethod
    def is_status_message(string):
        """Returns whether a string can be parsed into a status message."""
        try:
            Status(string=string)
        except ValueError:
            return False
        else:
            return True
